package services

import models.domain.genomics.Biosample
import models.domain.publications.EnaStudy
import play.api.Logging
import play.api.libs.json.*
import play.api.libs.ws.*

import java.util.UUID
import javax.inject.*
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class EnaIntegrationService @Inject()(ws: WSClient)(implicit ec: ExecutionContext) extends Logging {

  // ENA Browser API for XML (often more detailed for studies)
  // For JSON, use the ENA Portal API
  private val enaPortalApiBaseUrl = "https://www.ebi.ac.uk/ena/portal/api/search"
  private val ValidSexValues = Set("male", "female", "intersex")

  def getEnaStudyDetails(accession: String): Future[Option[EnaStudy]] = {
    // Example for PRJEB (Study) accessions. Other accessions (ERA, ERR, SRR) might need different queries.
    val query = s"study_accession=$accession"
    val fields = "study_accession,study_title,center_name,study_name,study_description" // Select relevant fields

    ws.url(enaPortalApiBaseUrl)
      .withQueryStringParameters(
        "result" -> "study",
        "query" -> query,
        "fields" -> fields,
        "format" -> "json"
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            val jsonArray = response.json.as[JsArray]
            jsonArray.value.headOption.map { studyJson =>
              EnaStudy(
                id = None, // Auto-generated by DB
                accession = (studyJson \ "study_accession").as[String],
                title = (studyJson \ "study_title").as[String].take(255),
                centerName = (studyJson \ "center_name").asOpt[String].getOrElse("N/A"), // Handle optional
                studyName = (studyJson \ "study_name").asOpt[String].getOrElse("N/A").take(255),
                details = (studyJson \ "study_description").asOpt[String].getOrElse("")
              )
            }
          case _ =>
            // Handle API errors (e.g., log, return None)
            logger.error(s"Error fetching ENA study $accession: ${response.status} - ${response.body}")
            None
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception during ENA API call for $accession: $e")
          None
      }
  }

  def getBiosamplesForStudy(studyAccession: String): Future[Seq[Biosample]] = {
    val fields = "sample_accession,description,sample_alias,center_name,sex,lat,lon,collection_date"

    ws.url(enaPortalApiBaseUrl)
      .withQueryStringParameters(
        "result" -> "sample",
        "query" -> s"study_accession=$studyAccession",
        "fields" -> fields,
        "format" -> "json",
        "limit" -> "0" // Get all results
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            val jsonArray = response.json.as[JsArray]
            jsonArray.value.map { sampleJson =>
              val latitudeOpt = (sampleJson \ "lat").asOpt[String].flatMap(_.toDoubleOption)
              val longitudeOpt = (sampleJson \ "lon").asOpt[String].flatMap(_.toDoubleOption)

              val geoCoord: Option[com.vividsolutions.jts.geom.Point] = (latitudeOpt, longitudeOpt) match {
                case (Some(lat), Some(lon)) =>
                  val geometryFactory = new com.vividsolutions.jts.geom.GeometryFactory()
                  Some(geometryFactory.createPoint(new com.vividsolutions.jts.geom.Coordinate(lon, lat)))
                case _ => None
              }

              Biosample(
                id = None,
                sampleAccession = (sampleJson \ "sample_accession").as[String],
                description = (sampleJson \ "description").asOpt[String].getOrElse(""),
                alias = (sampleJson \ "sample_alias").asOpt[String],
                centerName = (sampleJson \ "center_name").asOpt[String].getOrElse("N/A"),
                sex = validateSex((sampleJson \ "sex").asOpt[String]),
                geocoord = geoCoord,
                specimenDonorId = None,
                sampleGuid = UUID.randomUUID()
              )
            }.toSeq
          case _ =>
            logger.error(s"Error fetching ENA samples for study $studyAccession: ${response.status} - ${response.body}")
            Seq.empty
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception during ENA samples API call for $studyAccession: $e")
          Seq.empty
      }
  }

  private def validateSex(sex: Option[String]): Option[String] = {
    sex.flatMap { s =>
      val normalized = s.toLowerCase.trim
      Some(normalized).filter(ValidSexValues.contains)
    }
  }
}