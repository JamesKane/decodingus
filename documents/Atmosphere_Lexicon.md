# Atmosphere Lexicon Design

To support the "Atmosphere" integration within the AT Protocol (Bluesky) ecosystem, we define a specific Lexicon (schema) for Genomic Data. This allows `decodingus` to interact with the global network of Personal Data Stores (PDS) using standard XRPC methods, effectively turning genomic metadata into a portable, user-owned record type.

## Namespace: `com.decodingus.atmosphere`

This namespace covers the genomic operational data generated by BGS nodes and owned by Citizens.

---

### 1. Biosample Record (`com.decodingus.atmosphere.biosample`)

This record represents a single biological sample processed by a BGS node. It maps directly to the `ExternalBiosampleRequest` used in the MVP REST API.

**NSID:** `com.decodingus.atmosphere.biosample`

```json
{
  "lexicon": 1,
  "id": "com.decodingus.atmosphere.biosample",
  "defs": {
    "main": {
      "type": "record",
      "description": "A record representing a biological sample and its associated sequencing metadata.",
      "key": "tid",
      "record": {
        "type": "object",
        "required": ["sampleAccession", "donorIdentifier", "centerName", "sequenceData"],
        "properties": {
          "sampleAccession": {
            "type": "string",
            "description": "Unique identifier for the sample (e.g., UUID from BGS)."
          },
          "donorIdentifier": {
            "type": "string",
            "description": "Identifier for the specimen donor within the user's context."
          },
          "description": {
            "type": "string",
            "description": "Human-readable description of the sample."
          },
          "centerName": {
            "type": "string",
            "description": "The name of the Sequencing Center or BGS Node."
          },
          "sex": {
            "type": "string",
            "description": "Biological sex of the donor.",
            "knownValues": ["Male", "Female", "Other", "Unknown"]
          },
          "sequenceData": {
            "type": "ref",
            "ref": "#sequenceData",
            "description": "Technical details about the sequencing run."
          },
          "createdAt": {
            "type": "string",
            "format": "datetime"
          }
        }
      }
    },
    "sequenceData": {
      "type": "object",
      "description": "Technical metrics regarding the sequencing output.",
      "required": ["platformName", "testType", "files"],
      "properties": {
        "platformName": {
          "type": "string",
          "description": "Sequencing platform (e.g., ILLUMINA, PACBIO)."
        },
        "testType": {
          "type": "string",
          "description": "Type of test (e.g., WGS, EXOME)."
        },
        "reads": {
          "type": "integer",
          "description": "Total number of reads."
        },
        "readLength": {
          "type": "integer",
          "description": "Average read length."
        },
        "coverage": {
          "type": "float",
          "description": "Estimated sequencing coverage (e.g., 30.5)."
        },
        "files": {
          "type": "array",
          "items": {
            "type": "ref",
            "ref": "#fileInfo"
          }
        }
      }
    },
    "fileInfo": {
      "type": "object",
      "description": "Metadata about a specific data file (FASTQ, BAM, etc.).",
      "required": ["fileName", "fileFormat", "location"],
      "properties": {
        "fileName": {
          "type": "string"
        },
        "fileSizeBytes": {
          "type": "integer"
        },
        "fileFormat": {
          "type": "string",
          "knownValues": ["FASTQ", "BAM", "CRAM", "VCF"]
        },
        "checksum": {
            "type": "string",
            "description": "SHA-256 or similar checksum."
        },
        "location": {
          "type": "string",
          "format": "uri",
          "description": "The URI where the file is stored (e.g., s3://..., ipfs://...)."
        }
      }
    }
  }
}
```

## Integration Strategy

In the "Atmosphere" model, this Lexicon bridges the gap between the MVP REST API and the decentralized future:

1.  **MVP (Current):** The BGS Node (Rust) constructs a JSON payload matching the `ExternalBiosampleRequest`. It pushes this to `decodingus` via REST.
2.  **Phase 2 (Hybrid):** The BGS Node uses this Lexicon structure to construct the payload. `decodingus` accepts the payload and internally treats it as a valid ATP Record, potentially signing it on behalf of the user or the lab.
3.  **Phase 3 (Full Atmosphere):**
    *   The User grants the BGS Node "Write Access" to their PDS (repo).
    *   The BGS Node writes a `com.decodingus.atmosphere.biosample` record directly to the User's PDS.
    *   `decodingus` (acting as an AppView) ingests this record from the ATP Firehose, indexing it for the tree visualization.

## Mapping to Scala Models

| Lexicon Field | Scala Field (`ExternalBiosampleRequest`) |
| :--- | :--- |
| `sampleAccession` | `sampleAccession` |
| `donorIdentifier` | `donorIdentifier` |
| `centerName` | `centerName` |
| `sequenceData` | `sequenceData` (Mapped Object) |
| `files` | `files` (Mapped Object) |

## Lifecycle Management (AppView Logic)

As an AppView, `decodingus` subscribes to the AT Protocol Firehose to maintain a synchronized state of the genomic network.

### 1. The Firehose Event Stream
We listen for `com.atproto.sync.subscribeRepos` events containing operations for the collection `com.decodingus.atmosphere.biosample`.

### 2. Event Handling Strategy

| Event Action | Description | DecodingUs Logic |
| :--- | :--- | :--- |
| **Create** | User creates a new record. | 1. Extract `citizenDid` (Repo DID) and record body.<br>2. Invoke `ExternalBiosampleService.create`.<br>3. Store the `at_uri` (e.g., `at://did.../collection/rkey`) and `at_cid` in the `biosamples` table. |
| **Update** | User modifies an existing record. | 1. Lookup `Biosample` by `at_uri`.<br>2. Compare `at_cid` to ensure strictly newer version.<br>3. Update mutable fields (description, metrics, file URLs).<br>4. Update `at_cid`. |
| **Delete** | User removes a record. | 1. Lookup `Biosample` by `at_uri`.<br>2. Perform **Soft Delete** (mark as archived/hidden).<br>3. Remove from active visualization trees.<br>*Hard deletes are avoided to preserve scientific lineage unless legally required (GDPR).* |

### 3. Schema Requirements
To support robust syncing, the internal `biosamples` table requires tracking fields:

*   **`at_uri` (String, Unique):** The canonical decentralized address of the record. Used for lookups during Update/Delete.
*   **`at_cid` (String):** The content identifier (hash) of the current version. Used for optimistic locking and preventing replay attacks/race conditions.

