package services

import models.domain.genomics.Biosample
import models.domain.publications.StudySource.ENA
import models.domain.publications.{GenomicStudy, StudySource}
import play.api.Logging
import play.api.libs.json.*
import play.api.libs.ws.*
import services.ncbi.{NcbiApiClient, SraBiosampleData, SraStudyData}

import java.util.UUID
import javax.inject.*
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class GenomicStudyService @Inject()(ws: WSClient, ncbiApiClient: NcbiApiClient)(implicit ec: ExecutionContext) extends Logging {

  // ENA Browser API for XML (often more detailed for studies)
  // For JSON, use the ENA Portal API
  private val enaPortalApiBaseUrl = "https://www.ebi.ac.uk/ena/portal/api/search"
  private val ncbiEutilsBaseUrl = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils"

  private val ValidSexValues = Set("male", "female", "intersex")

  def getStudyDetails(accession: String): Future[Option[GenomicStudy]] = {
    determineSource(accession) match {
      case StudySource.ENA => getEnaStudyDetails(accession)
      case StudySource.NCBI_BIOPROJECT => ncbiApiClient.getSraStudyDetails(accession).map(_.map(sraToGenomicStudy))
      case StudySource.NCBI_GENBANK => getGenbankDetails(accession)
    }
  }

  private def sraToGenomicStudy(sra: SraStudyData): GenomicStudy =
    GenomicStudy(
      id = None,
      accession = sra.studyName,
      title = sra.title.take(255),
      centerName = sra.centerName,
      studyName = sra.studyName,
      details = sra.description,
      source = StudySource.NCBI_BIOPROJECT,
      submissionDate = None,
      bioProjectId = sra.bioProjectId,
      lastUpdate = None,
      molecule = None,
      topology = None,
      taxonomyId = None,
      version = None
    )

  private def determineSource(accession: String): StudySource = {
    val acc = accession.toUpperCase.trim

    acc match {
      // NCBI BioProjects
      case a if a.startsWith("PRJNA") => StudySource.NCBI_BIOPROJECT
      // ENA BioProjects
      case a if a.startsWith("PRJEB") => StudySource.ENA
      // ENA SRA Accessions
      case a if List("ERR", "ERX", "ERS", "ERA", "ERZ", "ERP").exists(a.startsWith) => StudySource.ENA
      // NCBI SRA Accessions
      case a if List("SRR", "SRX", "SRS", "SRP").exists(a.startsWith) => StudySource.NCBI_BIOPROJECT
      // NCBI RefSeq Accessions
      case a if List("NM_", "NP_", "XM_", "XP_", "NR_", "XR_", "WP_").exists(a.startsWith) => StudySource.NCBI_GENBANK
      // Common NCBI GenBank patterns
      case a if (
        // Single letter + 5 digits
        (a.length == 6 && a.head.isLetter && a.tail.forall(_.isDigit)) ||
          // Two letters + 6 digits
          (a.length == 8 && a.take(2).forall(_.isLetter) && a.drop(2).forall(_.isDigit)) ||
          // WGS pattern: four letters + "01" + 6 digits
          (a.length >= 12 &&
            a.take(4).forall(_.isLetter) &&
            a.slice(4, 6) == "01" &&
            a.drop(6).forall(_.isDigit))
        ) => StudySource.NCBI_GENBANK
      // Handle versioned accessions
      case a if a.contains(".") =>
        a.split("\\.") match {
          case Array(base, version) if version.forall(_.isDigit) => StudySource.NCBI_GENBANK
          case _ => StudySource.ENA // Default for unrecognized patterns
        }
      // Default to ENA for unrecognized patterns
      case _ => StudySource.ENA
    }
  }

  private def getEnaStudyDetails(accession: String): Future[Option[GenomicStudy]] = {
    // Example for PRJEB (Study) accessions. Other accessions (ERA, ERR, SRR) might need different queries.
    val query = s"study_accession=$accession"
    val fields = "study_accession,study_title,center_name,study_name,study_description" // Select relevant fields

    ws.url(enaPortalApiBaseUrl)
      .withQueryStringParameters(
        "result" -> "study",
        "query" -> query,
        "fields" -> fields,
        "format" -> "json"
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            val jsonArray = response.json.as[JsArray]
            jsonArray.value.headOption.map { studyJson =>
              GenomicStudy(
                id = None, // Auto-generated by DB
                accession = (studyJson \ "study_accession").as[String],
                title = (studyJson \ "study_title").as[String].take(255),
                centerName = (studyJson \ "center_name").asOpt[String].getOrElse("N/A"), // Handle optional
                studyName = (studyJson \ "study_name").asOpt[String].getOrElse("N/A").take(255),
                details = (studyJson \ "study_description").asOpt[String].getOrElse(""),
                source = ENA
              )
            }
          case _ =>
            // Handle API errors (e.g., log, return None)
            logger.error(s"Error fetching ENA study $accession: ${response.status} - ${response.body}")
            None
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception during ENA API call for $accession: $e")
          None
      }
  }

  def getBiosamplesForStudy(studyAccession: String): Future[Seq[Biosample]] = {
    determineSource(studyAccession) match {
      case StudySource.ENA =>
        getEnaBiosamples(studyAccession)
      case StudySource.NCBI_BIOPROJECT =>
        ncbiApiClient.getSraBiosamples(studyAccession)
          .map(_.map(sraToBiosample))
      case _ =>
        Future.successful(Seq.empty)
    }
  }

  private def sraToBiosample(sra: SraBiosampleData): Biosample = {
    // Extract sex from attributes if available
    val sex = validateSex(sra.attributes.get("sex"))

    // Try to extract coordinates from various possible attribute names
    val coordinates = for {
      lat <- sra.attributes.get("latitude")
        .orElse(sra.attributes.get("lat"))
        .flatMap(_.toDoubleOption)
      lon <- sra.attributes.get("longitude")
        .orElse(sra.attributes.get("lon"))
        .flatMap(_.toDoubleOption)
    } yield {
      val geometryFactory = new com.vividsolutions.jts.geom.GeometryFactory()
      geometryFactory.createPoint(new com.vividsolutions.jts.geom.Coordinate(lon, lat))
    }

    Biosample(
      id = None,
      sampleAccession = sra.sampleAccession,
      description = sra.description,
      alias = sra.alias,
      centerName = sra.centerName,
      sex = sex,
      geocoord = coordinates,
      specimenDonorId = None,
      sampleGuid = UUID.randomUUID()
    )
  }


  private def getEnaBiosamples(studyAccession: String): Future[Seq[Biosample]] = {
    val fields = "sample_accession,description,sample_alias,center_name,sex,lat,lon,collection_date"

    ws.url(enaPortalApiBaseUrl)
      .withQueryStringParameters(
        "result" -> "sample",
        "query" -> s"study_accession=$studyAccession",
        "fields" -> fields,
        "format" -> "json",
        "limit" -> "0" // Get all results
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            val jsonArray = response.json.as[JsArray]
            jsonArray.value.map { sampleJson =>
              val latitudeOpt = (sampleJson \ "lat").asOpt[String].flatMap(_.toDoubleOption)
              val longitudeOpt = (sampleJson \ "lon").asOpt[String].flatMap(_.toDoubleOption)

              val geoCoord: Option[com.vividsolutions.jts.geom.Point] = (latitudeOpt, longitudeOpt) match {
                case (Some(lat), Some(lon)) =>
                  val geometryFactory = new com.vividsolutions.jts.geom.GeometryFactory()
                  Some(geometryFactory.createPoint(new com.vividsolutions.jts.geom.Coordinate(lon, lat)))
                case _ => None
              }

              Biosample(
                id = None,
                sampleAccession = (sampleJson \ "sample_accession").as[String],
                description = (sampleJson \ "description").asOpt[String].getOrElse(""),
                alias = (sampleJson \ "sample_alias").asOpt[String],
                centerName = (sampleJson \ "center_name").asOpt[String].getOrElse("N/A"),
                sex = validateSex((sampleJson \ "sex").asOpt[String]),
                geocoord = geoCoord,
                specimenDonorId = None,
                sampleGuid = UUID.randomUUID()
              )
            }.toSeq
          case _ =>
            logger.error(s"Error fetching ENA samples for study $studyAccession: ${response.status} - ${response.body}")
            Seq.empty
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception during ENA samples API call for $studyAccession: $e")
          Seq.empty
      }
  }

  private def validateSex(sex: Option[String]): Option[String] = {
    sex.flatMap { s =>
      val normalized = s.toLowerCase.trim
      Some(normalized).filter(ValidSexValues.contains)
    }
  }

  private def getBioProjectDetails(accession: String): Future[Option[GenomicStudy]] = {
    // First do an esearch to get the proper ID
    val searchUrl = s"$ncbiEutilsBaseUrl/esearch.fcgi"
    val searchRequest = ws.url(searchUrl)
      .withQueryStringParameters(
        "db" -> "bioproject",
        "term" -> accession,
        "retmode" -> "json"
      )

    logger.info(s"NCBI esearch URL for BioProject: ${searchRequest.uri}")

    searchRequest.get().flatMap { searchResponse =>
      searchResponse.status match {
        case 200 =>
          logger.info(s"Raw BioProject search response for $accession:")
          logger.info(searchResponse.body)

          // Check for error in response
          (searchResponse.json \ "error").asOpt[String] match {
            case Some(error) =>
              logger.error(s"NCBI API returned error for $accession: $error")
              Future.successful(None)
            case None =>
              val ids = (searchResponse.json \\ "idlist").headOption
                .map(_.as[Seq[String]])
                .getOrElse(Seq.empty)

              if (ids.nonEmpty) {
                val summaryUrl = s"$ncbiEutilsBaseUrl/esummary.fcgi"
                val summaryRequest = ws.url(summaryUrl)
                  .withQueryStringParameters(
                    "db" -> "bioproject",
                    "id" -> ids.head,
                    "retmode" -> "json"
                  )

                logger.info(s"NCBI esummary URL for BioProject: ${summaryRequest.uri}")

                summaryRequest.get().map { response =>
                  response.status match {
                    case 200 =>
                      logger.info(s"Raw BioProject summary response:")
                      logger.info(response.body)

                      // Check for error in summary response
                      (response.json \ "error").asOpt[String] match {
                        case Some(error) =>
                          logger.error(s"NCBI API returned error in summary for $accession: $error")
                          None
                        case None =>
                          val result = response.json \\ "result"
                          val data = result.head.as[JsObject]

                          Some(GenomicStudy(
                            id = None,
                            accession = accession,
                            title = (data \ "title").asOpt[String].getOrElse("").take(255),
                            centerName = (data \ "organization").asOpt[String].getOrElse("N/A"),
                            studyName = accession,
                            details = (data \ "description").asOpt[String].getOrElse(""),
                            source = StudySource.NCBI_BIOPROJECT,
                            bioProjectId = Some(accession)
                          ))
                      }
                    case _ =>
                      logger.error(s"Error fetching BioProject summary: ${response.status} - ${response.body}")
                      None
                  }
                }
              } else {
                logger.error(s"No BioProject ID found for $accession")
                Future.successful(None)
              }
          }
        case _ =>
          logger.error(s"Error searching for BioProject: ${searchResponse.status} - ${searchResponse.body}")
          Future.successful(None)
      }
    }
  }

  private def getGenbankDetails(accession: String): Future[Option[GenomicStudy]] = {
    val url = s"$ncbiEutilsBaseUrl/efetch.fcgi"

    ws.url(url)
      .withQueryStringParameters(
        "db" -> "nucleotide",
        "id" -> accession,
        "rettype" -> "gb",
        "retmode" -> "xml"
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            try {
              val xml = scala.xml.XML.loadString(response.body)

              // Extract GBSeq elements
              val seqElement = xml \\ "GBSeq"

              seqElement.headOption.map { seq =>
                val references = parseReferences(seq \\ "GBReference")

                GenomicStudy(
                  id = None,
                  accession = (seq \\ "GBSeq_accession-version").text,
                  title = (seq \\ "GBSeq_definition").text,
                  centerName = (seq \\ "GBSeq_source").text,
                  studyName = (seq \\ "GBSeq_locus").text,
                  details = (seq \\ "GBSeq_comment").text,
                  source = StudySource.NCBI_GENBANK,
                  submissionDate = Some(parseGenbankDate((seq \\ "GBSeq_create-date").text)),
                  lastUpdate = Some(parseGenbankDate((seq \\ "GBSeq_update-date").text)),
                  molecule = Some((seq \\ "GBSeq_moltype").text),
                  topology = Some((seq \\ "GBSeq_topology").text),
                  taxonomyId = (seq \\ "GBSeq_taxonomy-id").headOption.map(_.text.toInt),
                  version = Some((seq \\ "GBSeq_accession-version").text.split("\\.")(1))
                )
              }
            } catch {
              case e: Exception =>
                logger.error(s"Error parsing GenBank XML for $accession: ${e.getMessage}")
                None
            }
          case status =>
            logger.error(s"Error fetching GenBank entry $accession: $status - ${response.body}")
            None
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception during GenBank API call for $accession: $e")
          None
      }
  }

  private def parseGenbankDate(date: String): java.time.LocalDate = {
    // GenBank dates are in format "DD-MMM-YYYY"
    java.time.LocalDate.parse(
      date,
      java.time.format.DateTimeFormatter.ofPattern("dd-MMM-yyyy", java.util.Locale.ENGLISH)
    )
  }

  private def parseReferences(refs: scala.xml.NodeSeq): Seq[Map[String, String]] = {
    refs.map { ref =>
      Map(
        "authors" -> (ref \\ "GBReference_authors" \\ "GBAuthor").map(_.text).mkString(", "),
        "title" -> (ref \\ "GBReference_title").text,
        "journal" -> (ref \\ "GBReference_journal").text,
        "pubmed" -> (ref \\ "GBReference_pubmed").text
      ).filter(_._2.nonEmpty) // Remove empty values
    }.toSeq
  }

}