@import models.domain.genomics.{CoverageBenchmark, SequencingLab}

@(benchmarks: Seq[CoverageBenchmark], lab: Option[SequencingLab])(implicit messages: Messages)
@* Helper function to calculate 95% confidence interval *@
@calculateCI(mean: Option[Double], stddev: Option[Double], n: Int) = @{
    (mean, stddev) match {
        case (Some(m), Some(sd)) if n > 1 =>
            val margin = 1.96 * sd / math.sqrt(n)
            val lower = m - margin
            val upper = m + margin
            f"$m%.1f ($lower%.1f-$upper%.1f)"
        case (Some(m), _) =>
            f"$m%.1f"
        case _ =>
            "-"
    }
}

<div class="table-responsive">
    <table class="table table-striped table-hover">
        <thead class="table-dark">
            <tr>
                <th>@messages("benchmark.header.testType")</th>
                <th>@messages("benchmark.header.contig")</th>
                <th>@messages("benchmark.header.meanReadLen")</th>
                <th>@messages("benchmark.header.readLenRange")</th>
                <th>@messages("benchmark.header.meanInsertSize")</th>
                <th>@messages("benchmark.header.insertSizeRange")</th>
                <th>@messages("benchmark.header.meanDepth")</th>
                <th>@messages("benchmark.header.noCoverage")</th>
                <th>@messages("benchmark.header.lowQuality")</th>
                <th>@messages("benchmark.header.callable")</th>
                <th>@messages("benchmark.header.meanMappingQuality")</th>
                <th>@messages("benchmark.header.samples")</th>
            </tr>
        </thead>
        <tbody>
        @for(benchmark <- benchmarks) {
            <tr>
                <td>@benchmark.testType</td>
                <td>@benchmark.contig</td>
                <td>@benchmark.meanReadLen.map(v => f"$v%.1f").getOrElse("-")</td>
                <td>
                    @benchmark.minReadLen.map(_.toString).getOrElse("-") -
                    @benchmark.maxReadLen.map(_.toString).getOrElse("-")
                </td>
                <td>@benchmark.meanInsertLen.map(v => f"$v%.1f").getOrElse("-")</td>
                <td>
                    @benchmark.minInsertLen.map(_.toString).getOrElse("-") -
                    @benchmark.maxInsertLen.map(_.toString).getOrElse("-")
                </td>
                <td>@calculateCI(benchmark.meanDepthAvg, benchmark.meanDepthStddev, benchmark.numSamples)</td>
                <td>@calculateCI(benchmark.basesNoCoverageAvg, benchmark.basesNoCoverageStddev, benchmark.numSamples)</td>
                <td>@calculateCI(benchmark.basesLowQualMappingAvg, benchmark.basesLowQualMappingStddev, benchmark.numSamples)</td>
                <td>@calculateCI(benchmark.basesCallableAvg, benchmark.basesCallableStddev, benchmark.numSamples)</td>
                <td>@benchmark.meanMappingQuality.map(v => f"$v%.1f").getOrElse("-")</td>
                <td>
                    <span class="badge bg-primary">@benchmark.numSamples</span>
                </td>
            </tr>
        }
        </tbody>
    </table>
</div>

@if(benchmarks.isEmpty) {
    <div class="alert alert-info" role="alert">
        <i class="bi bi-info-circle"></i> @messages("benchmark.noData")
    </div>
}
