package services

import models.domain.genomics.Biosample
import models.domain.publications.{GenomicStudy, StudySource}
import models.domain.publications.StudySource.ENA
import play.api.Logging
import play.api.libs.json.*
import play.api.libs.ws.*

import java.util.UUID
import javax.inject.*
import scala.concurrent.{ExecutionContext, Future}

@Singleton
class GenomicStudyService @Inject()(ws: WSClient)(implicit ec: ExecutionContext) extends Logging {

  // ENA Browser API for XML (often more detailed for studies)
  // For JSON, use the ENA Portal API
  private val enaPortalApiBaseUrl = "https://www.ebi.ac.uk/ena/portal/api/search"
  private val ncbiEutilsBaseUrl = "https://eutils.ncbi.nlm.nih.gov/entrez/eutils"

  private val ValidSexValues = Set("male", "female", "intersex")

  def getStudyDetails(accession: String): Future[Option[GenomicStudy]] = {
    determineSource(accession) match {
      case StudySource.ENA => getEnaStudyDetails(accession)
      case StudySource.NCBI_BIOPROJECT => getNcbiStudyDetails(accession)
      case StudySource.NCBI_GENBANK => getGenbankDetails(accession)
    }
  }

  private def determineSource(accession: String): StudySource = {
    accession match {
      case acc if acc.startsWith("PRJ") || acc.startsWith("SRP") => StudySource.NCBI_BIOPROJECT
      // GenBank accession patterns
      case acc if acc.matches("[A-Z]\\d{5,8}") => StudySource.NCBI_GENBANK // Traditional GenBank
      case acc if acc.matches("[A-Z]{2}_\\d+") => StudySource.NCBI_GENBANK // RefSeq
      case acc if acc.matches("[A-Z]{4}\\d{8,10}") => StudySource.NCBI_GENBANK // WGS
      // Default to ENA for other patterns
      case _ => StudySource.ENA
    }
  }

  def getEnaStudyDetails(accession: String): Future[Option[GenomicStudy]] = {
    // Example for PRJEB (Study) accessions. Other accessions (ERA, ERR, SRR) might need different queries.
    val query = s"study_accession=$accession"
    val fields = "study_accession,study_title,center_name,study_name,study_description" // Select relevant fields

    ws.url(enaPortalApiBaseUrl)
      .withQueryStringParameters(
        "result" -> "study",
        "query" -> query,
        "fields" -> fields,
        "format" -> "json"
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            val jsonArray = response.json.as[JsArray]
            jsonArray.value.headOption.map { studyJson =>
              GenomicStudy(
                id = None, // Auto-generated by DB
                accession = (studyJson \ "study_accession").as[String],
                title = (studyJson \ "study_title").as[String].take(255),
                centerName = (studyJson \ "center_name").asOpt[String].getOrElse("N/A"), // Handle optional
                studyName = (studyJson \ "study_name").asOpt[String].getOrElse("N/A").take(255),
                details = (studyJson \ "study_description").asOpt[String].getOrElse(""),
                source = ENA
              )
            }
          case _ =>
            // Handle API errors (e.g., log, return None)
            logger.error(s"Error fetching ENA study $accession: ${response.status} - ${response.body}")
            None
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception during ENA API call for $accession: $e")
          None
      }
  }

  def getBiosamplesForStudy(studyAccession: String): Future[Seq[Biosample]] = {
    val fields = "sample_accession,description,sample_alias,center_name,sex,lat,lon,collection_date"

    ws.url(enaPortalApiBaseUrl)
      .withQueryStringParameters(
        "result" -> "sample",
        "query" -> s"study_accession=$studyAccession",
        "fields" -> fields,
        "format" -> "json",
        "limit" -> "0" // Get all results
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            val jsonArray = response.json.as[JsArray]
            jsonArray.value.map { sampleJson =>
              val latitudeOpt = (sampleJson \ "lat").asOpt[String].flatMap(_.toDoubleOption)
              val longitudeOpt = (sampleJson \ "lon").asOpt[String].flatMap(_.toDoubleOption)

              val geoCoord: Option[com.vividsolutions.jts.geom.Point] = (latitudeOpt, longitudeOpt) match {
                case (Some(lat), Some(lon)) =>
                  val geometryFactory = new com.vividsolutions.jts.geom.GeometryFactory()
                  Some(geometryFactory.createPoint(new com.vividsolutions.jts.geom.Coordinate(lon, lat)))
                case _ => None
              }

              Biosample(
                id = None,
                sampleAccession = (sampleJson \ "sample_accession").as[String],
                description = (sampleJson \ "description").asOpt[String].getOrElse(""),
                alias = (sampleJson \ "sample_alias").asOpt[String],
                centerName = (sampleJson \ "center_name").asOpt[String].getOrElse("N/A"),
                sex = validateSex((sampleJson \ "sex").asOpt[String]),
                geocoord = geoCoord,
                specimenDonorId = None,
                sampleGuid = UUID.randomUUID()
              )
            }.toSeq
          case _ =>
            logger.error(s"Error fetching ENA samples for study $studyAccession: ${response.status} - ${response.body}")
            Seq.empty
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception during ENA samples API call for $studyAccession: $e")
          Seq.empty
      }
  }

  private def validateSex(sex: Option[String]): Option[String] = {
    sex.flatMap { s =>
      val normalized = s.toLowerCase.trim
      Some(normalized).filter(ValidSexValues.contains)
    }
  }

  private def getNcbiStudyDetails(accession: String): Future[Option[GenomicStudy]] = {
    val url = s"$ncbiEutilsBaseUrl/esummary.fcgi"

    ws.url(url)
      .withQueryStringParameters(
        "db" -> "bioproject",
        "term" -> accession,
        "retmode" -> "json"
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            val result = response.json \\ "result"
            val projectData = result.head.as[JsObject]

            Some(GenomicStudy(
              id = None,
              accession = accession,
              title = (projectData \ "title").asOpt[String].getOrElse("").take(255),
              centerName = (projectData \ "organization").asOpt[String].getOrElse("N/A"),
              studyName = accession,  // Use accession as study name if none provided
              details = (projectData \ "description").asOpt[String].getOrElse(""),
              source = StudySource.NCBI_BIOPROJECT
            ))
          case _ => None
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception fetching NCBI BioProject details for accession $accession: $e")
          None
      }
  }

  private def getGenbankDetails(accession: String): Future[Option[GenomicStudy]] = {
    val url = s"$ncbiEutilsBaseUrl/efetch.fcgi"

    ws.url(url)
      .withQueryStringParameters(
        "db" -> "nucleotide",
        "id" -> accession,
        "rettype" -> "gb",
        "retmode" -> "xml"
      )
      .get()
      .map { response =>
        response.status match {
          case 200 =>
            try {
              val xml = scala.xml.XML.loadString(response.body)

              // Extract GBSeq elements
              val seqElement = xml \\ "GBSeq"

              seqElement.headOption.map { seq =>
                val references = parseReferences(seq \\ "GBReference")

                GenomicStudy(
                  id = None,
                  accession = (seq \\ "GBSeq_accession-version").text,
                  title = (seq \\ "GBSeq_definition").text,
                  centerName = (seq \\ "GBSeq_source").text,
                  studyName = (seq \\ "GBSeq_locus").text,
                  details = (seq \\ "GBSeq_comment").text,
                  source = StudySource.NCBI_GENBANK,
                  submissionDate = Some(parseGenbankDate((seq \\ "GBSeq_create-date").text)),
                  lastUpdate = Some(parseGenbankDate((seq \\ "GBSeq_update-date").text)),
                  molecule = Some((seq \\ "GBSeq_moltype").text),
                  topology = Some((seq \\ "GBSeq_topology").text),
                  taxonomyId = (seq \\ "GBSeq_taxonomy-id").headOption.map(_.text.toInt),
                  version = Some((seq \\ "GBSeq_accession-version").text.split("\\.")(1))
                )
              }
            } catch {
              case e: Exception =>
                logger.error(s"Error parsing GenBank XML for $accession: ${e.getMessage}")
                None
            }
          case status =>
            logger.error(s"Error fetching GenBank entry $accession: $status - ${response.body}")
            None
        }
      }
      .recover {
        case e: Exception =>
          logger.error(s"Exception during GenBank API call for $accession: $e")
          None
      }
  }

  private def parseGenbankDate(date: String): java.time.LocalDate = {
    // GenBank dates are in format "DD-MMM-YYYY"
    java.time.LocalDate.parse(
      date,
      java.time.format.DateTimeFormatter.ofPattern("dd-MMM-yyyy", java.util.Locale.ENGLISH)
    )
  }

  private def parseReferences(refs: scala.xml.NodeSeq): Seq[Map[String, String]] = {
    refs.map { ref =>
      Map(
        "authors" -> (ref \\ "GBReference_authors" \\ "GBAuthor").map(_.text).mkString(", "),
        "title" -> (ref \\ "GBReference_title").text,
        "journal" -> (ref \\ "GBReference_journal").text,
        "pubmed" -> (ref \\ "GBReference_pubmed").text
      ).filter(_._2.nonEmpty) // Remove empty values
    }.toSeq
  }

}